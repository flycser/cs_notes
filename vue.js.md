# Vue.js 教程

## 基础

### 声明式渲染

文本差值

```html
<div id="app">
  {{ message }}
</div>
```

```vue
var app = new Vue({
	el: '#app',
	data: {
		message: 'hello Vue!'
	}
})
```

绑定元素attribute

```html
<div id="app2">
  <span v-bind:title="message">
  	text
  </span>
</div>
```

```vue
var app2 = new Vue({
	el: '#app2',
	data: {
		message: 'text'
	}
})
```

Vue采用模版语法来声明式地将数据渲染进DOM系统

**指令**，"v-"开头

### 条件与循环

v-if

V-for

### 处理用户输入

v-on

v-model

### 组件化应用构建

### Vue实例

#### 创建一个Vue实例

当创建一个Vue实例时，可以传入一个**选项对象**，所有的Vue组建都是Vue实例，并且接受相同的选项对象

备注：什么是选项对象？

#### 数据与方法

当一个Vue实例被创建时，将data对象中的所有的属性加入到Vue的**响应式系统**中，当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值

当这些数据改变时，视图会进行重渲染，只有当实例被创建时就已经存在于data中的属性才是响应式的，添加一个新的属性，对新属性的改动将**不会触发**任何视图的更新，如果知道随后需要一个属性，但是一开始它为空或不存在，那么仅需要设置一些初始值

备注：Object.freeze()将会阻止修改现有属性

#### 实例生命周期钩子

每个Vue实例在被创建时都要经过一系列初始化过程，如设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等，在这些过程中会运行一些叫做生命周期钩子的函数，可以使用户在不同阶段添加自己代码，如created、mounted、updated、destroyed

生命周期钩子的this上下文指向调用它的Vue实例

> 不要在选项属性或回调上使用箭头函数，因为箭头函数并没有this，this会作为变量一直向上级词法作用于查找，直到找到为止，经常导致`Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误

#### 生命周期图示

new Vue() -> 初始化/事件 & 生命周期 -> beforeCreate -> 初始化/注入 & 校验 -> created -> beforeMount -> mounted -> 挂载完毕 -> beforeUpdated -> updated -> beforeDestroy -> 解除绑定/销毁子组件以及事件监听器 -> destroyed

### 模板语法

Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至Vue实例的数据，所有Vue.js的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数，结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少

#### 插值

##### 文本

数据绑定最常见的形式就是使用“Mustache”语法(双大括号)的文本插值，Mustache标签将会被替代为对应数据上属性的值，无论何时，绑定的数据上属性发生了改变，插值处的内容都会更新

通过执行v-once指令，能执行一次性地插值，当数据改变时，插值处的内容不会更新

##### 原始HTML

双大括号会将数据解释为普通文本，使用v-html指令，会输出html

##### Attribute

Mustache语法不能作用在HTML attribute上，需使用v-bind指令，对于布尔型属性，如果绑定属性值时null，undefined，或false，则属性甚至不会被包含在渲染出来的元素中

##### 使用JavaScript表达式

数据绑定不仅可以绑定简单的属性键值，Vue.js还提供了完全的JavaScript表达式支持，每个绑定都只能包含单个表达式，语句与控制流都不会生效

#### 指令

指令(Directives)是带有v-前缀的特殊attribute，指令attribute的值预期是单个JavaScript表达式(v-for例外)，指令的指责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM

##### 参数

一些指令能够接受一个“参数”，在指令名称之后以冒号表示

##### 动态参数

可以用方括号括起来的JavaScript表达式作为一个指令的参数

**对动态参数的值的约束**，动态参数预期会求出一个字符串，异常情况下值为null，这个特殊的null可以被显性地用于移除绑定，任何其他非字符串类型的值都将会出发一个警告

**对动态参数表达式的约束**，动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在HTML attribute名里是无效的

在DOM中使用模板时(直接在一个HTML文件里撰写模板)，还需要避免使用大些字符来命名键名，因为浏览器会把attribute名全部强制转为小写

##### 修饰符

修饰符(modifier)是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定

#### 缩写

v-前缀作为一种视觉提示，用来识别模板中Vue特定的attribute，Vue为v-bind和v-on这两个最常用的指令，提供了特定简写

##### v-bind缩写

```html
<a v-bind:href="url">...</a> <!-- 完整语法 -->
<a :href="url">...</a> <!-- 缩写 -->
<a :[key]="url"> ... </a> <!-- 动态参数的缩写 -->
```

##### v-on缩写

```html
<a v-on:click="doSomething">...</a> <!-- 完整语法 -->
<a @click="doSomething">...</a> <!-- 缩写 -->
<a @[event]="doSomething"> ... </a> <!-- 动态参数的缩写 -->
```

### 计算属性和侦听器

#### 计算属性

模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的，在模板中放入太多的逻辑会让模板过重且难以维护，所以，对于任何复杂逻辑，都应当使用计算属性

##### 计算属性缓存VS方法

我们可以通过在表达式中调用方法来达到相同效果，两种方式的最终结果确实是完全相同的，然而，不同的计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时，它们才会重新求值，这就意味着只要属性还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数，相比之下，每当出发重新渲染时，调用方法将总会再次执行函数

```javascript
computed: { // 该计算属性不再更新，因为Date.now()不是响应式依赖
	now: function () {
  	return Date.now()
  }
}
```

##### 计算属性VS侦听属性

Vue提供一种更通用的方式来观察和响应Vue实例上的数据变动: 侦听属性，watch滥用

##### 计算属性的setter

计算属性默认只有getter，不过在需要时也可以提供一个setter

#### 侦听器



