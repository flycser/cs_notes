# Docker 教程

## 常用命令

### 公有仓库镜像Pull到本地再上传到私有仓库

```shell
docker login # 登录到公有仓库
docker pull libray/neo4j
docker logout
```

```shell
docker tag neo4j hub.mlamp.cn/mas-ir/neo4j # 打标签
```



```shell
docker login hub.mlamp.cn # 登录到私有仓库
docker push hub.mlamp.cn/mas-ir/neo4j # push到私有仓库
```

### 本地运行

```shell
docker run -it -d -p 7474:7474 -p 7687:7687 neo4j:3.5.12.1
```

### 登录私有仓库

```shell
docker login hub.mlamp.cn # 登录
docker logout # 登出
```



## Docker简介

Docker基于Go语言开发，基于Linux内核的cgroup，namespace，以及OverlayFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为**容器**

- 容易不需要进行硬件虚拟以及运行完整操作系统，对系统资源的利用率更高
- Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统，因此具有更快速的启动时间
- Docker镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性
- 使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署
- 由于Docker确保了执行环境的一致性，使得应用的迁移更加容易
- Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易

## 基本概念

### 镜像 (Image)

操作系统分为内核和用户空间，Docker镜像就相当于一个root文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数(如匿名卷、环境变量、用户等)，**镜像不包含任何动态数据**，其内容在构建之后也不会改变

#### 分层存储

镜像包含操作系统完整的root文件系统，提及庞大，因为Docker设计时，充分利用了Union FS技术，设计为分层存储的架构，镜像知识一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成

镜像构建时，会逐层构建，每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己的这一层，如，删除前一层文件的操作，实际不是真的删除前一层的文件，二是仅在当前层标记为该文件已删除，在最终容器运行的时候，虽然不会看到这个文件，但是该文件会一直跟随镜像，因此，构建镜像时，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉

分层存储有利于复用与定制，可以添加新层，定制所需内容，构建新镜像

### 容器 (Container)

镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建、启动、停止、删除、暂停等

容器的实质是**进程**，与宿主进程比较，容器进程拥有独立的命名空间，可以拥有自己的root文件系统，网络配置，进程空间，用户ID空间

容器运行时，以镜像为基础层，在其上创建一个当前容器的存储层，成为**容器存储层**，容器存储层的生命周期与容器一样，容器消亡，也随之消亡，任何保存于容器存储层的信息都会随容器删除而丢失，因此，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化，所有的文件写入操作，都应该使用数据卷(Volume)，或者绑定宿主目录，在这些位置的读写，会跳过容器存储层，直接对宿主机(或网络存储)发生读写，性能和稳定性更高，使用数据卷后，容器删除或者重新运行后，数据不会丢失

### 仓库 (Repository)

镜像构建完成后，需要一个集中存储、分发镜像的服务，即**Docker Registry**

一个Docker Registry中可以包含多个仓库，每个仓库可以包含多个**标签**(Tag)，每个标签对应一个镜像，标签可以用来对应软件镜像的不同版本，<仓库名>:<标签>指定软件的具体镜像，不给出标签，则使用latest作为默认标签

仓库名一般两段式，xxx/xxx，前者为用户名，后者为软件名

#### Docker Registry公开服务

Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务，如Docker Hub

#### 私有Docker Registry

本地搭建，开源版本Harbor和Sonatype Nexus

## 使用镜像

### 获取镜像

```bash
docker pull [option] [Docker Registry address[:port]/]repository:[tag]
```

仓库名，两段式，对于Docker Hub，如果不给出用户名，默认为```library```，即官方镜像

#### 运行

启动ubuntu:18.04镜像bash并进行交互式操作命令

```bash
docker run -it --rm ubuntu:18.04 bash
```

```-i```交互式操作，```-t```终端，```--rm```，容器退出后随之将其删除，放在镜像名后的```bash```是命令

### 列出镜像

```bash
docker image ls
```

#### 镜像体积

Docker Hub上的体积是压缩后的体积，与本地实际占用磁盘空间大小不同，可以通过命令查看镜像、容器、数据卷所占用空间

```bash
docker system df
```

#### 虚悬镜像

由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为<none>的镜像，这类无标签镜像也被称为**虚悬镜像**(dangling image)，查看命令

```bash
docker image ls -f dangling=true
```

一般来说，虚悬镜像已经失去存在价值，可以随意删除，删除命令

```bash
docker imagee prune
```

#### 中间层镜像

